---------------------------------
异常类
类 Throwable
直接已知子类： 
  Error：错误，必须修改源代码
  Exception 编译期异常
    RuntimeException “运行期间”抛出的异常 

异常处理语法：
try{
  // 可能会出现异常的代码
}catch(Exception e){
  sout(e)
}

------
throw: 在指定的方法中抛出指定的异常

格式： 
  throw new xxxException("异常产生的原因")

------
Objects类中的静态方法：判断传入的对象是否为空
Objects.requireNonNull(obj) 参数是obj对象
Objects.requireNonNull(obj,"提示的信息")

------
异常处理的第一种方式：声明异常

throws关键字： 
当方法内部抛出异常对象的时候,那么我们就必须处理这个异常对象
可以使用throws关键字处理异常对象,会把异常对象声明抛出给方法的调用者处理(自己不处理,给别人处理),最终交给JVM处理-->中断处理

使用格式： 在方法声明时使用；配合throw使用
修饰符 返回值类型 方法名(参数列表) throws AAAExcepiton,BBBExcepiton...{
    throw new AAAExcepiton("产生原因");
    throw new BBBExcepiton("产生原因");
    ...
}

注意:
  1.throws关键字必须写在方法声明处
  2.throws关键字后边声明的异常必须是Exception或者是Exception的子类
  3.方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常
      如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可
  4.调用了一个声明抛出异常的方法,我们就必须的处理声明的异常
      要么继续使用throws声明抛出,交给方法的调用者处理,最终交给JVM
      要么try...catch自己处理异常

------
异常处理的第二种方式：捕获异常

格式:
  try{
      可能产生异常的代码
  }catch(定义一个异常的变量,用来接收try中抛出的异常对象){ //try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象
      异常的处理逻辑,异常异常对象之后,怎么处理异常对象
      一般在工作中,会把异常的信息记录到一个日志中
  }
  ...
  catch(异常类名 变量名){

  }
注意:
  1.try中可能会抛出多个异常对象,那么就可以使用多个catch来处理这些异常对象
  2.如果try中产生了异常,那么就会执行catch中的异常处理逻辑,执行完毕catch中的处理逻辑,继续执行try...catch之后的代码
    如果try中没有产生异常,那么就不会执行catch中异常的处理逻辑,执行完try中的代码,继续执行try...catch之后的代码

------
Throwable类中定义了3个异常处理的方法
  String getMessage() 返回此 throwable 的简短描述。
  String toString() 返回此 throwable 的详细消息字符串。
  void printStackTrace()  JVM打印异常对象,默认此方法,打印的异常信息是最全面的

------
finally代码块
格式:
  try{
      可能产生异常的代码
  }catch(定义一个异常的变量,用来接收try中抛出的异常对象){
      异常的处理逻辑,异常异常对象之后,怎么处理异常对象
      一般在工作中,会把异常的信息记录到一个日志中
  }
  ...
  catch(异常类名 变量名){

  }finally{
      无论是否出现异常都会执行
  }
注意:
  1.finally不能单独使用,必须和try一起使用
  2.finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO)

------
多个异常使用捕获又该如何处理呢？
  1. 多个异常分别处理。
  2. 多个异常一次捕获，多次处理。
  3. 多个异常一次捕获一次处理。

/*
一个try多个catch注意事项:
    catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错
    ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException
*/  

//运行时异常被抛出可以不处理。即不捕获也不声明抛出。
//默认给虚拟机处理,终止程序,什么时候不抛出运行时异常了,在来继续执行程序

如果finally有return语句,永远返回finally中的结果,避免该情况.

子父类的异常:
    - 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。
    - 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
注意:
    父类异常时什么样,子类异常就什么样

------
自定义异常？    


---------------------------------
多线程
---------------------------------
并发： 指两个或多个事件在同一个时间段内发生         一个人吃两个馒头
并行： 指两个或多个事件在同一个时刻发生（同时发生）  两个人吃两个馒头

------
进程： 一个软件程序
线程： 是进程中的一个执行单位

cpu 中央处理器
  AMD
  Inter

------
线程调度
  分时调度： 所有线程轮流使用cpu的使用权，平均分配每个线程占用的CPU的时间
  抢占式调度： 优先让优先级高的线程使用cpu，优先级相同就随机执行
java属于抢占式调度  

------
主线程： 执行主方法（main）的线程
之前写的程序都是单线程

------
------
创建多线程
第一种方法：
  创建Thread类的子类，覆写run()方法，设置线程任务
  子类的对象就可以调用start()方法，开启新线程，java虚拟机调用该线程的run方法

//1.创建一个Thread类的子类
public class MyThread extends Thread{
    //2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)
    @Override
    public void run() {
        for (int i = 0; i <20 ; i++) {
            System.out.println("run:"+i);
        }
    }
}

------
多线程原理

------
Thread类常用方法

  getName()  获取线程的名字
  Thread.currentThread() // 静态方法，返回的是当前线程

  setName()  设置线程名称
  Thread(String name) 构造方法
    创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字

      public MyThread(String name){
          super(name);//把线程名称传递给父类,让父类(Thread)给子线程起一个名字
      }

  sleep(毫秒数)  静态方法，使线程暂停毫秒

------
------
创建多线程
第二种方法：

实现步骤:
  1.创建一个Runnable接口的实现类
  2.在实现类中重写Runnable接口的run方法,设置线程任务
  3.创建一个Runnable接口的实现类对象
  4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象. 
  5.调用Thread类中的start方法,开启新的线程执行run方法
    RunnableImpl implements Runnable
    RunnableImpl run = new RunnableImpl();
    new Thread(run).start()

------
实现Runnable接口创建多线程程序的好处:
  1.避免了单继承的局限性
      一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类
      实现了Runnable接口,还可以继承其他的类,实现其他的接口
  2.增强了程序的扩展性,降低了程序的耦合性(解耦)
      实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)
      实现类中,重写了run方法:用来设置线程任务；传递不同的实现类，实现不同的任务
      创建Thread类对象,调用start方法:用来开启新线程  

------
匿名内部类实现多线程

匿名内部类作用:简化代码
    把子类继承父类,重写父类的方法,创建子类对象合一步完成
    把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成
匿名内部类的最终产物:子类/实现类对象,而这个类没有名字

格式:
    new 父类/接口(){
        重复父类/接口中的方法
    };

---------------------------------
线程安全问题： 多线程访问共享数据

------
解决线程安全问题：
第一种方法：同步代码块
格式：
  synchronized(锁对象){
    可能会出现线程安全问题的代码(访问了共享数据的代码)
  }

注意:
  1.通过代码块中的锁对象,可以使用任意的对象
  2.但是必须保证多个线程使用的锁对象是同一个
  3.锁对象作用:
      把同步代码块锁住,只让一个线程在同步代码块中执行  


------
第二种方法：同步方法（静态同步方法）

使用步骤:
    1.把访问了共享数据的代码抽取出来,放到一个方法中
    2.在方法上添加synchronized修饰符

格式:定义方法的格式
修饰符 synchronized 返回值类型 方法名(参数列表){
    可能会出现线程安全问题的代码(访问了共享数据的代码)
}

------
解决线程安全问题的三种方案:使用Lock锁

使用步骤:
  1.在成员位置创建一个ReentrantLock对象
  2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
  3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁