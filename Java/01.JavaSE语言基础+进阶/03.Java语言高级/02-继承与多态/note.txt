java三大特性： 封装（private）、继承（extend）、 多态
---------------------------------
继承：
继承是多态的前提，没有继承就没有多态
继承主要解决的问题： 共性抽取
------
父类、基类、超类
子类、派生类

------
在继承的关系中：“子类就是一个父类”
继承的格式： 
public class 子类 extends 父类{}

------
继承中成员变量的访问特点： 就近原则，没有就向上找

------
super  访问父类的变量和方法

------
方法的重写
重写（override）： 方法名一样，参数列表也一样，也叫覆写
重载（overload）： 方法名一样，参数列表不一样

覆盖重写注意事项：
  @Override 写在方法前面，用来检测是不是有效的正确覆盖重写
  子类方法的返回值必须小于等于父类方法的返回值范围
  子类方法的权限必须大于等于父类方法的权限修饰符
  	public > protected > (default)(什么都不写) > private

super.父类方法	将父类的方法拿过来使用  

------
继承中构造方法的访问特点：
  子类必须调用父类的构造方法（子类的构造方法中有一个默认的super(),调用父类无参构造）
  只有子类构造方法，才能调用父类构造方法
  super()的父类构造调用，必须放在第一个语句，且只能有一个

---------------------------------
抽象类
  概念：
  格式： public abstract class 类名 {}
抽象方法：必须在抽象类中
  格式： 加上abstract， 然后去掉大括号和里面的内容，直接分号结束
        public abstract void method();

使用：
  1、不能直接创建抽象类对象(不能new)
  2、必须用一个子类来继承抽象父类
  3、子类必须覆盖重写（实现）抽象父类中的所有抽象方法。去掉抽象方法的abstract关键字，然后补上方法体
  4、创建子类对象进行使用

注意事项：  
  1、抽象类不能直接创建对象
  2、抽象父类可以有构造方法
  3、抽象类中，不一定包含抽象方法；但是有抽象方法的类必定是抽象类
  4、抽象类的子类，必须覆写抽象父类中所有的抽象方法

---------------------------------
接口
接口就是一种‘公共的规范标准’，只要符合规范标准，就可以通用
接口是一种引用数据类型，最重要的内容就是其中的抽象方法

基本定义格式：  
public interface 接口名称{
  // 内容
}

接口中可以包含：常量、抽象方法、默认方法、静态方法、私有方法

------
接口中的抽象方法定义
  public abstract void 方法名称(); // （public abstract：固定写法，可以写其中任何一个，可以不写，都是抽象方法）
  void 方法名称();  // 不能有方法体，方法的三要素可以随意定义

接口的使用
  不能直接使用，必须有一个实现类来实现该接口
  必须覆写接口中所有的抽象方法
  如果实现类并没有覆写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类
  实现类覆写抽象方法： 去掉abstract
格式：
  public class 实现类名称 implements 接口名称{}

------
接口中默认方法的定义  （java8新增） 解决接口升级的问题

格式：
  public default 返回值类型 方法名称（参数列表）{ // 方法体 }

使用： 
  默认方法会被实现类继承，实现类也可以覆写接口的默认方法

------
接口中静态方法的定义  （java8新增）

格式： 
  public static 返回值类型 方法名称（参数列表）{ // 方法体 }

使用： 
  直接使用 接口名称.方法名（），不能通过接口实现类的对象调用

------
接口中私有方法的定义  （java9新增）

1、普通私有方法：解决多个默认方法之间重复代码问题
格式： 
  private 返回值类型 方法名称（参数列表）{ // 方法体 }
2、静态私有方法：解决多个静态方法之间重复代码问题
格式： 
  private static 返回值类型 方法名称（参数列表）{ // 方法体 }

------
接口中常量的定义和使用 （成员变量： 其实是常量）

必须使用public static final三个关键字进行修饰
格式： public static final 数据类型 常量名称（大写） = 数据值;（必须赋值）
    这其实是一个常量，一旦赋值，不可以修改
    一旦使用了final关键字进行修饰，说明不可改变
    接口中的常量，可以省略public static final，不写会被默认加上
使用： 
    通过接口名直接调用

------
一个实现类可以同时实现多个接口
public class 类名 implements 接口A, 接口B{}
    实现类必须全部覆写所有的抽象方法

/*
使用接口的时候，需要注意：

1. 接口是没有静态代码块或者构造方法的。
2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
格式：
public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
    // 覆盖重写所有抽象方法
}
3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
5. 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。
 */
 继承优先于接口实现

------
/*
1. 类与类之间是单继承的。直接父类只有一个。
2. 类与接口之间是多实现的。一个类可以实现多个接口。
3. 接口与接口之间是多继承的。

注意事项：
1. 多个父接口当中的抽象方法如果重复，没关系。
2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。
 */


---------------------------------
多态
继承是多态的前提

学生类 继承 人类
一个对象拥有多种形态（人的形态和学生的形态）
对象的多态性

------
使用： 父类引用指向子类对象
格式： 左父右子
  父类名称 对象名 = new 子类名称()
  接口名称 对象名 = new 实现类名称()

------
通过对象访问[成员变量]规则： 看等号左边是谁，优先用谁，没有则向上找  
  编译看左，运行看左

通过对象访问[成员方法]规则： 看new的是谁就找谁的方法
  编译看左，运行看右

------
多态的好处

------
对象的向上转型：父类引用指向子类对象
  格式： 父类名称 对象名 = new 子类名称() （多态的写法）
  举例： 创建了一直猫，把它当做动物看
  从小范围转向大范围，向上转型一定是安全的
  弊端： 无法调用子类特有的方法
  解决方案： 使用向下转型还原
对象的向下转型
  格式： 子类名称 对象名 = (子类名称) 父类对象
  含义： 将父类对象还原为本来的子类对象
  类似于  int num = (int) 10.0; 数据类型的强制转换

------
instanceof
  格式： 对象 instanceof 类型  
  返回boolean值，判断前面的对象能否当做后面类型的实例
向下转型前先进行if判断，否则可能发生异常