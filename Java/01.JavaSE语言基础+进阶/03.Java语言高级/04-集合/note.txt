---------------------------------
Collection集合  单列    Map 双列

------
Iterator接口
  对Collection集合进行迭代（遍历）的迭代器（取出集合中元素的通用方法）
  hasNext() 判断集合中还有没有下一个元素，有就返回true
  next()    取出集合中的下一个元素

Collection接口中有一个iterator()方法，返回迭代器的实现类对象  

使用步骤：
  Collection<String> coll = new ArrayList<>();

  （多态）接口          =  实现类对象
  Iterator<String> it = coll.iterator();  // 泛型和Collection的泛型相同
    coll.iterator() // 获取迭代器的实现类对象，并且会把指针（索引）指向集合的-1位置

  判断有没有下一个元素： it.hasNext();      // 判断有没有下一个元素
  取出元素：      String s = it.next();   // 取出元素，并把指针向后移动一位
  ... 有多少元素就重复这两步多少次

  优化： 使用while循环
  while(it.hasNext()){
    String e = it.next();
    System.out.println(e);
  }

  使用for循环
  for(Iterator<String> it2 = coll.iterator(); it.hasNext(); ){
    String e = it.next();
    System.out.println(e);
  }
------
增强for循环（for each）（jdk 1.5） 底层使用的也是迭代器  快捷键：要被循环的集合或数组.for
用来遍历集合和数组

格式： 
  for(集合/数组的数据类型 变量名: 集合名/数组名){
    sout(变量名);
  }

ArrayList<String> list = new ArrayList<>();
list.add("aa")
list.add("bb")
list.add("bb")
for(String s: list){
  sout(s);
}

int[] arr = {1,3,4,5,7};
for(int i:arr){
  sout(i);
}

---------------------------------
泛型：是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型；可以看成一个变量，用来接收数据类型

E e:Element元素
T t:Type类型

创建集合对象的时候，就会确定泛型的数据类型
ArrayList<String> list = new ArrayList<>();

------
泛型的好处
  集合不使用泛型，默认类型就是Object类型，可以存储任意类型的数据
  弊端： 不安全，会引发异常

/*
  创建集合对象,使用泛型
  好处:
      1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型
      2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错)
    弊端:
      泛型是什么类型,只能存储什么类型的数据
*/

------
/*
    定义一个含有泛型的类,模拟ArrayList集合
    泛型是一个未知的数据类型,当我们不确定什么什么数据类型的时候,可以使用泛型
    泛型可以接收任意的数据类型,可以使用Integer,String,Student...
    创建对象的时候确定泛型的数据类型
 */

------
/*
    定义含有泛型的方法:泛型定义在方法的修饰符和返回值类型之间

    格式:
        修饰符 <泛型> 返回值类型 方法名(参数列表(使用泛型)){
            方法体;
        }

    含有泛型的方法,在调用方法的时候确定泛型的数据类型
    传递什么类型的参数,泛型就是什么类型
 */  

------
定义含有泛型的接口

------
泛型的通配符：使用？表示，代表任意的数据类型
不能创建对象使用（定义的使用不能用），只能作为方法的参数使用

---------------------------------
数据结构（集合的）

栈：    先进后出

队列：  先进先出

数组：  查询快，增删慢

链表：  查询慢，增删快
  链表中每一个元素称之为一个节点，一个节点包含了自己的地址、数据、下一个节点的地址

红黑树：趋近于平衡树，查询的速度非常快

二叉树：最多只能有两个子树
排序树/查找树： 左子树小，右子树大
平衡树：左右子树相等
不平衡树：


---------------------------------
List集合 ： 继承Collection接口
特点：
  有序
  有索引
  可重复

  带索引的方法：
  add(index, element)   添加
  get(index)            获取
  remove(index)         移除
  set(index,element)    替换

  //List集合遍历有3种方式
  //使用普通的for循环
  for(int i=0; i<list.size(); i++){
      //public E get(int index):返回集合中指定位置的元素。
      String s = list.get(i);
      System.out.println(s);
  }
  System.out.println("-----------------");
  //使用迭代器
  Iterator<String> it = list.iterator();
  while(it.hasNext()){
      String s = it.next();
      System.out.println(s);
  }
  System.out.println("-----------------");
  //使用增强for
  for (String s : list) {
      System.out.println(s);
  }

  注意:
    操作索引的时候,一定要防止索引越界异常
    IndexOutOfBoundsException:索引越界异常,集合会报
    ArrayIndexOutOfBoundsException:数组索引越界异常
    StringIndexOutOfBoundsException:字符串索引越界异常

------
实现类

ArrayList类 多线程
底层是数组结构，特点：查询快，增删慢

LinkedList类 多线程 
底层是链表结构：查询慢，增删快

使用LinkedList集合特有的方法，不能使用多态

Vector集合  单线程
底层是数组结构，v1.2被ArrayList取代

---------------------------------
Set接口： 继承Collection接口
特点：
  无索引，不能使用for循环
  无重复

实现类：
HashSet
  无序、无索引、不重复
底层是哈希表结构： 查询速度快

------
哈希值

Object类 hashCode()方法： 返回对象的哈希值

------
哈希表
数组+链表 或 数组+红黑树
特点： 速度快

------
Set存储元素不重复的原理

---------------------------------
Collections 工具类
静态方法：

addAll(list,...element)   往集合中添加一些元素
shuffle(list)  打乱集合顺序

sort(list)     按默认的规则升序排序
注意：如果是自定义类型排序，必须实现Comparable接口，重写compareTo方法

sort(list,new Comparator<Integer>{
  // 重写比较的规则
  @Override
  public int compare(Integer o1,Integer o2){
    return o1-o2; // 升序
  }
})
Comparator是一个接口 

扩展：组合式排序

---------------------------------
---------------------------------
Map集合 双列          Collection集合  单列

------
实现类
HashMap LinkedHashMap

java.util.Map<k,v>集合
  Map集合的特点:
      1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value)
      2.Map集合中的元素,key和value的数据类型可以相同,也可以不同
      3.Map集合中的元素,key是不允许重复的,value是可以重复的
      4.Map集合中的元素,key和value是一一对应

  java.util.HashMap<k,v>集合 implements Map<k,v>接口
  HashMap集合的特点:
      1.HashMap集合底层是哈希表:查询的速度特别的快
          JDK1.8之前:数组+单向链表
          JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度
      2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致

  java.util.LinkedHashMap<k,v>集合 extends HashMap<k,v>集合
  LinkedHashMap的特点:
      1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序)
      2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的

------
常用方法
put()
remove()
get()
containsKey()

------
遍历方法
keySet()    返回的是set集合

    //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中
    Set<String> set = map.keySet();

    //2.遍历set集合,获取Map集合中的每一个key
    //使用迭代器遍历Set集合
    Iterator<String> it = set.iterator();
    while (it.hasNext()){
        String key = it.next();
        //3.通过Map集合中的方法get(key),通过key找到value
        Integer value = map.get(key);
        System.out.println(key+"="+value);
    }
    
    //使用增强for遍历Set集合
    for(String key : set){
        //3.通过Map集合中的方法get(key),通过key找到value
        Integer value = map.get(key);
        System.out.println(key+"="+value);
    }
    
    //使用增强for遍历Set集合，简化第一步
    for(String key : map.keySet()){
        //3.通过Map集合中的方法get(key),通过key找到value
        Integer value = map.get(key);
        System.out.println(key+"="+value);
    }

entrySet()

  Map集合遍历的第二种方式:使用Entry对象遍历

  Map集合中的方法:
      Set<Map.Entry<K,V>> entrySet() 返回此映射中包含的映射关系的 Set 视图。

  实现步骤:
      1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中
      2.遍历Set集合,获取每一个Entry对象
      3.使用Entry对象中的方法getKey()和getValue()获取键与值

  //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中
        Set<Map.Entry<String, Integer>> set = map.entrySet();

  //2.遍历Set集合,获取每一个Entry对象
  //使用迭代器遍历Set集合
  Iterator<Map.Entry<String, Integer>> it = set.iterator();
  while(it.hasNext()){
      Map.Entry<String, Integer> entry = it.next();
      //3.使用Entry对象中的方法getKey()和getValue()获取键与值
      String key = entry.getKey();
      Integer value = entry.getValue();
      System.out.println(key+"="+value);
  }
  System.out.println("-----------------------");
  for(Map.Entry<String,Integer> entry:set){
      //3.使用Entry对象中的方法getKey()和getValue()获取键与值
      String key = entry.getKey();
      Integer value = entry.getValue();
      System.out.println(key+"="+value);
  }    

------
HashMap 储存自定义类型键值对

子类： LinkedHashMap extends HashMap  
有序的集合

------
Hashtable 和HashMap相似
不能存空
单线程

子类Properties ：是一个唯一和IO流相结合的集合

------
jdk 1.9为
list，set，map添加一个静态方法：of();用于批量添加数据,相当于list.add()和map.put();

---------------------------------
Debug追踪

f8  逐行执行
f7  进入到方法中
shift+f8  跳出方法
f9  跳到下一个断点，没有就结束
ctrl+f2 退出debug模式，停止程序