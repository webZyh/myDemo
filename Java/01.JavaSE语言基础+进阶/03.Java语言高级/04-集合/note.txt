---------------------------------
Collection集合

------
Iterator接口
  对Collection集合进行迭代（遍历）的迭代器（取出集合中元素的通用方法）
  hasNext() 判断集合中还有没有下一个元素，有就返回true
  next()    取出集合中的下一个元素

Collection接口中有一个iterator()方法，返回迭代器的实现类对象  

使用步骤：
  Collection<String> coll = new ArrayList<>();

  （多态）接口          =  实现类对象
  Iterator<String> it = coll.iterator();  // 泛型和Collection的泛型相同
    coll.iterator() // 获取迭代器的实现类对象，并且会把指针（索引）指向集合的-1位置

  判断有没有下一个元素： it.hasNext();      // 判断有没有下一个元素
  取出元素：      String s = it.next();   // 取出元素，并把指针向后移动一位
  ... 有多少元素就重复这两步多少次

  优化： 使用while循环
  while(it.hasNext()){
    String e = it.next();
    System.out.println(e);
  }

  使用for循环
  for(Iterator<String> it2 = coll.iterator(); it.hasNext(); ){
    String e = it.next();
    System.out.println(e);
  }
------
增强for循环（for each）（jdk 1.5） 底层使用的也是迭代器  快捷键：要被循环的集合或数组.for
用来遍历集合和数组

格式： 
  for(集合/数组的数据类型 变量名: 集合名/数组名){
    sout(变量名);
  }

ArrayList<String> list = new ArrayList<>();
list.add("aa")
list.add("bb")
list.add("bb")
for(String s: list){
  sout(s);
}

int[] arr = {1,3,4,5,7};
for(int i:arr){
  sout(i);
}

---------------------------------
泛型：是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型；可以看成一个变量，用来接收数据类型

E e:Element元素
T t:Type类型

创建集合对象的时候，就会确定泛型的数据类型
ArrayList<String> list = new ArrayList<>();

------
泛型的好处
  集合不使用泛型，默认类型就是Object类型，可以存储任意类型的数据
  弊端： 不安全，会引发异常

/*
  创建集合对象,使用泛型
  好处:
      1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型
      2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错)
    弊端:
      泛型是什么类型,只能存储什么类型的数据
*/

------
/*
    定义一个含有泛型的类,模拟ArrayList集合
    泛型是一个未知的数据类型,当我们不确定什么什么数据类型的时候,可以使用泛型
    泛型可以接收任意的数据类型,可以使用Integer,String,Student...
    创建对象的时候确定泛型的数据类型
 */

------
/*
    定义含有泛型的方法:泛型定义在方法的修饰符和返回值类型之间

    格式:
        修饰符 <泛型> 返回值类型 方法名(参数列表(使用泛型)){
            方法体;
        }

    含有泛型的方法,在调用方法的时候确定泛型的数据类型
    传递什么类型的参数,泛型就是什么类型
 */  

------
定义含有泛型的接口

------
泛型的通配符：使用？表示，代表任意的数据类型
不能创建对象使用（定义的使用不能用），只能作为方法的参数使用

---------------------------------
数据结构（集合的）

栈：    先进后出

队列：  先进先出

数组：  查询快，增删慢

链表：  查询慢，增删快
  链表中每一个元素称之为一个节点，一个节点包含了自己的地址、数据、下一个节点的地址

红黑树：趋近于平衡树，查询的速度非常快

二叉树：最多只能有两个子树
排序树/查找树： 左子树小，右子树大
平衡树：左右子树相等
不平衡树：


---------------------------------
List集合 ： 继承Collection接口
特点：
  有序
  有索引
  可重复

  带索引的方法：
  add(index, element)   添加
  get(index)            获取
  remove(index)         移除
  set(index,element)    替换

  //List集合遍历有3种方式
  //使用普通的for循环
  for(int i=0; i<list.size(); i++){
      //public E get(int index):返回集合中指定位置的元素。
      String s = list.get(i);
      System.out.println(s);
  }
  System.out.println("-----------------");
  //使用迭代器
  Iterator<String> it = list.iterator();
  while(it.hasNext()){
      String s = it.next();
      System.out.println(s);
  }
  System.out.println("-----------------");
  //使用增强for
  for (String s : list) {
      System.out.println(s);
  }

  注意:
    操作索引的时候,一定要防止索引越界异常
    IndexOutOfBoundsException:索引越界异常,集合会报
    ArrayIndexOutOfBoundsException:数组索引越界异常
    StringIndexOutOfBoundsException:字符串索引越界异常

------
实现类

ArrayList类 多线程
底层是数组结构，特点：查询快，增删慢

LinkedList类 多线程 
底层是链表结构：查询慢，增删快

使用LinkedList集合特有的方法，不能使用多态

Vector集合  单线程
底层是数组结构，v1.2被ArrayList取代

---------------------------------
Set接口： 继承Collection接口
特点：
  无索引，不能使用for循环
  无重复

实现类：
HashSet
  无序、无索引、不重复
底层是哈希表结构： 查询速度快

------
哈希值

Object类 hashCode()方法： 返回对象的哈希值

------
哈希表
数组+链表 或 数组+红黑树
特点： 速度快

------
Set存储元素不重复的原理

---------------------------------
Collections 工具类
静态方法：

addAll(list,...element)   往集合中添加一些元素
shuffle(list)  打乱集合顺序

sort(list)     按默认的规则升序排序
注意：如果是自定义类型排序，必须实现Comparable接口，重写compareTo方法

sort(list,new Comparator<Integer>{
  // 重写比较的规则
  @Override
  public int compare(Integer o1,Integer o2){
    return o1-o2; // 升序
  }
})
Comparator是一个接口 

扩展：组合式排序

---------------------------------