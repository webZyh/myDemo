https://regexper.com
---------------------------------------------------------------------------
常用方法：  (下面用reg表示正则,str表示字符串)

RegExp对象中的方法：
  test(): 在字符串中查找符合正则的内容，若查找到返回true,反之返回false.
  用法：reg.test(str)

  exec(): 用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。
  用法：reg.exec(str)

  以上两个方法均受特殊属性g的影响；如果设置了全局属性g，下一次进行查找时，在正则表达式内部有一个lastIndex来记录匹配的位置，第一次调用test()后，那么lastIndex就不再等于0，从上一次匹配的索引后进行匹配，可以手动设置lastIndex属性  reg.lastIndex = 0;

字符串的方法：
  search() ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回 -1 
  用法： str.search(reg)

  match() 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。
  用法： str.match(reg)

  replace(): 查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。
  用法： str.replace(reg, 新的字符串/回调函数) （在回调函数中，第一个参数指的是‘每次’匹配成功的字符）
---------------------------------------------------------------------------
正则中的字符
----------------------------
() :  小括号，叫做分组符。就相当于数学里面的括号；正则中的每一个带小括号的项，都叫做这个正则的子项，在方法中，子项用$index来表示，当match()不加g的时候才可以获取到子项的集合
  var str = '2013-6-7';
  var re = /(\d+)(-)/g;
  str = str.replace(re,function($0,$1,$2){
  //replace()中如果有子项， //第一个参数：$0（匹配成功后的整体结果 2013- 6-）,
  // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d 2013, 6)
  //第三个参数 : $2(匹配成功的第二个分组，这里指的是- - - ) 
  return $1 + '.'; //分别返回2013. 6.
  });
  alert( str ); //2013.6.7
  //整个过程就是利用子项把2013- 6- 分别替换成了2013. 6. 最终弹出2013.6.7
----------------------------
[] ： 表示某个集合中的任意一个，比如 [abc] 整体代表一个字符 匹配 a b c 中的任意一个，也可以是范围，[0-9] 范围必须从小到大 。
[^a] 整体代表一个字符 ： ^写在[]里面的话，就代表排除的意思
----------------------------
量词：代表出现的次数

{n,m}：至少出现n次，最多m次
{n,} :至少n次
* :任意次 相当于{0,}
？ ：零次或一次 相当于{0,1}
+ ：一次或任意次相当于 {1,}
{n}： 正好n次
----------------------------
^ : 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。
---------------------------------------------------------------------------

元字符：
\s : 空格
\S : 非空格
\d : 数字
\D : 非数字
\w : 字符 ( 字母 ，数字，下划线_ )
\W : 非字符例子：是否有不是数字的字符
.（点）: 任意字符
\. : 真正的点
\b : 独立的部分 （ 起始，结束，空格 ）
\B : 非独立的部分
\a 表示重复的某个子项 比如：
  \1 重复的第一个子项     / (a) (b) (c) \1/-----匹配 abca
  \2 重复的第二个子项     / (a) (b) (c) \2/------匹配 abcb 